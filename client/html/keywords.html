<div ng-controller="MainController as main">
    <prism></prism>
    <div class="container">
        <h1 id="KeyAndFeat">Keywords & Features in TypeScript</h1>
        <h2 id="Let"><code>let</code></h2>
        <p><code>var</code> Variables in JavaScript are function scoped. This is different from many other languages (C#
            / Java etc.) where the variables are block scoped. If you bring a block scoped mindset to JavaScript, you
            would expect the following to print 123, instead it will print 456:
        </p>
        <pre class="line-numbers codeBox"><code class="language-typescript">var foo = 123;
if (true) {
   var foo = 456;
}
console.log(foo); // 456</code></pre>
        <p>This is because { does not create a new variable scope. The variable foo is the same inside the if block as
            it is outside the if block. This is a common source of errors in JavaScript programming. This is why
            TypeScript (and ES6) introduces the let keyword to allow you to define variables with true block scope. That
            is if you use let instead of var you get a true unique element disconnected from what you might have defined
            outside the scope. The same example is demonstrated with let:</p>
        <pre class="line-numbers codeBox"><code class="language-typescript">let foo = 123;
if (true) {
    let foo = 456;
}
console.log(foo); // 123</code></pre>
        <p>Another place where let would save you from errors is loops.
        </p>
        <pre class="line-numbers codeBox"><code class="language-typescript">var index = 0;
var array = [1, 2, 3];
for (let index = 0; index < array.length; index++) {
    console.log(array[index]);
}
console.log(index); // 0</code></pre>
        <p>In all sincerity we find it better to use let whenever possible as it leads to lesser surprises for new and
            existing multi-lingual developers.</p>

<h2 id="FuncNewScope">Functions create a new Scope</h2>
<p>Since we mentioned it, we'd like to demonstrate that functions create a new variable scope in JavaScript. Consider
    the following:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var foo = 123;
function test() {
    var foo = 456;
}
test();
console.log(foo); // 123</code></pre>
<p>This behaves as you would expect. Without this it would be very difficult to write code in JavaScript.</p>
<h2 id="GeneratedJS">The Generated JS</h2>
<p>The JS generated by TypeScript is simple renaming of the let variable if a similar name already exists in the
    surrounding scope. E.g. the following is generated as is with a simple replacement of var with let:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">if (true) {
       let foo = 123;
}

// becomes //

if (true) {
       var foo = 123;
}</code></pre>
<p>However if the variable name is already taken by the surrounding scope then a new variable name is generated as shown
    (notice _foo):
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var foo = '123';
if (true) {
    let foo = 123;
}

// becomes //

var foo = '123';
if (true) {
    var _foo = 123; // Renamed
}</code></pre>
<h1 id="LetInClosures"><code>let</code> in Closures</h1>
<p>A common programming interview question for a JavaScript developer is what is the log of this simple file:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}</code></pre>
<p>One would have expected it to be 0,1,2. Surprisingly it is going to be 3 for all three functions. Reason is that all
    three functions are using the variable i from the outer scope and at the time we execute them (in the second loop)
    the value of i will be 3 (that's the termination condition for the first loop).
    A fix would be to create a new variable in each loop specific to that loop iteration. As we've learned before we can
    create a new variable scope by creating a new function and immediately executing it (i.e. the IIFE pattern from
    classes <code>(function() { /* body */ })();)</code> as shown below:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    (function() {
        var local = i;
        funcs.push(function() {
            console.log(local);
        })
    })();
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}</code></pre>
<p>Here the functions close over (hence called a closure) the local variable (conveniently named local) and use that
    instead of the loop variable <code></code>i.
    Note that closures come with a performance impact (they need to store the surrounding state).
    The ES6 let keyword in a loop would have the same behavior as the previous example:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var funcs = [];
// create a bunch of functions
for (let i = 0; i < 3; i++) { // Note the use of let
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}</code></pre>
<p>Using a <code>let</code> instead of <code>var</code> creates a variable <code>i</code> unique to each loop iteration.
    To summarize, let is extremely useful to have for the vast majority of code. It can greatly enhance your code
    readability and decrease the chance of a programming error
</p>
<h1 id="Const"><code>const</code></h1>
<p><code>const</code> is a very welcomed addition offered by ES6 / TypeScript. It allows you to be immutable with
    variables. This is good from a documentation as well as a runtime perspective. To use <code>const</code> just
    replace <code>var</code> with <code>const</code>:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo = 123;</code></pre>
<p>The syntax is much better (IMHO) than other languages that force the user to type something like <code>let constant
    foo</code> i.e. a variable + behavior specifier.
    <code>const</code> is a good practice for both readability and maintainability and avoids using <i>magic
        literals</i> e.g.
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">// Low readability
if (x > 10) {
}

// Better!
const maxRows = 10;
if (x > maxRows) {
}</code></pre>
<p>const declarations must be initialized
    The following is a compiler error:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo; // ERROR: const declarations must be initialized</code></pre>
<p>Left hand side of assignment cannot be a constant
    Constants are immutable after creation, so if you try to assign them to a new value it is a compiler error:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo = 123;
foo = 456; // ERROR: Left-hand side of an assignment expression cannot be a constant</code></pre>
<h2 id="BlockScoped">Block Scoped</h2>
<p>A <code>const</code> is block scoped like we saw with <a href="A const is block scoped like we saw with let:">
    let</a>:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo = 123;
if (true) {
    const foo = 456; // Allowed as its a new variable limited to this `if` block
}
</code></pre>
<h2 id="DeepImmutability">Deep Immutability</h2>
<p>A const works with object literals as well, as far as protecting the variable reference is concerned:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo = { bar: 123 };
foo = { bar: 456 }; // ERROR : Left hand side of an assignment expression cannot be a constant</code></pre>
<p>However it still allows sub properties of objects to be mutated, as shown below:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">const foo = { bar: 123 };
foo.bar = 456; // Allowed!
console.log(foo); // { bar: 456 }
</code></pre>
<p>For this reason I recommend using const with literals or immutable data structures.
</p>
<h1 id="ForOf"><code>for...of</code></h1>
<p>A common error experienced by beginning JavaScript developers is that for...infor an array does not iterate over the
    array items. Instead it iterates over the keys of the object passed in. This is demonstrated in the below example.
    Here you would expect 9,2,5 but you get the indexes 0,1,2:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var someArray = [9, 2, 5];
for (var item in someArray) {
    console.log(item); // 0,1,2
}</code></pre>
<p>This is one of the reasons why for...of exists in TypeScript (and ES6). The following iterates over the array
    correctly logging out the members as expected:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var someArray = [9, 2, 5];
for (var item of someArray) {
    console.log(item); // 9,2,5
}</code></pre>
<p>Similarly TypeScript has no trouble going through a string character by character using for...of:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var hello = "is it me you're looking for?";
for (var char of hello) {
    console.log(char); // is it me you're looking for?
}</code></pre>
<h2 id="JSGeneration">JS Generation</h2>
<p>For pre ES6 targets TypeScript will generate the standard for (var i = 0; i < list.length; i++) kind of loop. For
    example here's what gets generated for our previous example:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var someArray = [9, 2, 5];
for (var item of someArray) {
    console.log(item);
}

// becomes //

for (var _i = 0; _i < someArray.length; _i++) {
    var item = someArray[_i];
    console.log(item);
}</code></pre>
<p>You can see that using <code>for...of</code> makes intent clearer and also decreases the amount of code you have to
    write (and variable names you need to come up with).
</p>
<h2 id="Limits">Limitations</h2>
<p>If you are not targeting ES6 or above, the generated code assumes the property length exists on the object and that
    the object can be indexed via numbers e.g. obj[2]. So it is only supported on string and array for these legacy JS
    engines.
    If TypeScript can see that you are not using an array or a string it will give you a clear error "is not an array
    type or a string type";
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">let articleParagraphs = document.querySelectorAll("article > p");
// Error: Nodelist is not an array type or a string type
for (let paragraph of articleParagraphs) {
    paragraph.classList.add("read");
}</code></pre>
<p>Use for...of only for stuff that you know to be an array or a string. Note that this limitation might be removed in a
    future version of TypeScript.
    To summarize, you would be surprised at how many times you will be iterating over the elements of an array. The next
    time you find yourself doing that, give for...of a go. You might just make the next person who reviews your code
    happy.
</p>
<h1 id="MultilineStrings">Multiline Strings</h1>
<p>Ever wanted to put a newline in a JavaScript string? Perhaps you wanted to embed some lyrics? You would have needed
    to escape the literal newline using our favorite escape character<code>\</code>, and then put a new line into the
    string manually \n at the next line. This is shown below:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var lyrics = "Never gonna give you up \
\nNever gonna let you down";</code></pre>
<p>With TypeScript you can just use a template string:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var lyrics = `Never gonna give you up
Never gonna let you down`;</code></pre>
<h1 id="ArrowFunctions">Arrow Functions</h1>
<p>Lovingly called the fat arrow (because -> is a thin arrow and => is a fat arrow) and also called a lambda function
    (because of other languages). Another commonly used feature is the fat arrow function ()=>something. The motivation
    for a fat arrow is:
    1. You don't need to keep typing function
    2. It lexically captures the meaning of this
    3. It lexically captures the meaning of arguments
    For a language that claims to be functional, in JavaScript you tend to be typing function quite alot. The fat arrow
    makes it simple for you to create a function
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var inc = (x)=>x+1;</code></pre>
<p>this has traditionally been a pain point in JavaScript. As a wise man once said "I hate JavaScript as it tends to
    lose the meaning of this all too easily". Fat arrows fix it by capturing the meaning of this from the surrounding
    context. Consider this pure JavaScript class:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">function Person(age) {
    this.age = age;
    this.growOld = function() {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 1, should have been 2</code></pre>
<p>If you run this code in the browser this within the function is going to point to window because window is going to
    be what executes the growOld function. Fix is to use an arrow function:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">function Person(age) {
    this.age = age;
    this.growOld = () => {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2</code></pre>
<p>The reason why this works is the reference to this is captured by the arrow function from outside the function body.
    This is equivalent to the following JavaScript code (which is what you would write yourself if you didn't have
    TypeScript):
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">function Person(age) {
    this.age = age;
    var _this = this;  // capture this
    this.growOld = function() {
        _this.age++;   // use the captured this
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2

</code></pre>
<p>Note that since you are using TypeScript you can be even sweeter in syntax and combine arrows with classes:</p>
<pre class="line-numbers codeBox"><code class="language-typescript">class Person {
    constructor(public age:number) {}
    growOld = () => {
        this.age++;
    }
}
var person = new Person(1);
setTimeout(person.growOld,1000);

setTimeout(function() { console.log(person.age); },2000); // 2</code></pre>
<a href="https://egghead.io/lessons/typescript-make-usages-of-this-safe-in-class-methods">A video about this pattern
</a>
<h2 id="Tips">A few helpful Tips</h2>
<h3>Tip: Arrow Function Need</h3>
<p> Beyond the terse syntax, you only need to use the fat arrow if you are going to give the function to someone else to
    call. Effectively:
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">var growOld = person.growOld;
// Then later someone else calls it:
growOld();</code></pre>
<p>If you are going to call it yourself, i.e.
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">person.growOld();</code></pre>
<p>then this is going to be the correct calling context (in this example person).
</p>
<h3>Tip: Arrow functions with libraries that use this</h3>
<p> Many libraries do this e.g. jQuery iterables (one example http://api.jquery.com/jquery.each/) will use this to pass
    you the object that it is currently iterating over. In this case if you want to access the library passed this as
    well as the surrounding context just use a temp variable like _self like you would in the absence of arrow
    functions.</p>
<pre class="line-numbers codeBox"><code class="language-typescript">let _self = this;
something.each(function() {
    console.log(_self); // the lexically scoped value
    console.log(this); // the library passed value
});</code></pre>
<h3>Tip: Arrow functions and inheritance</h3>
<p> If you have an instance method as an arrow function then it goes on this. Since there is only one this such
    functions cannot participate in a call to super(super only works on prototype members). You can easily get around it
    by creating a copy of the method before overriding it in the child.
</p>
<pre class="line-numbers codeBox"><code class="language-typescript">class Adder {
    constructor(public a: number) {}
    // This function is now safe to pass around
    add = (b: number): number => {
        return this.a + b;
    }
}

class ExtendedAdder extends Adder {
    // Create a copy of parent before creating our own
    private superAdd = this.add;
    // Now create our override
    add = (b: number): number => {
        return this.superAdd(b);
    }
}</code></pre>
<h2 id="CodeVs">Code in JavaScript vs code in TypeScript</h2>
<p>To examine how TypeScript actually transpiles to JavaScript we have offered a few examples in order to see some of
    the ways that the TS transpiler decided to write to JavaScript version of our TS input code.</p>
<p>Here, we simply define a class named Planet which holds two variables namely, mass and moons and also within our
    <code>Planet</code> class we add a <code>reportMoons()</code> functions to log the information contained in our variables. We can see that
    the JavaScript transfomartion of the TS code is still relatively similar to the original but with added wrappers and
    functions to achieve that OOP feel.</p>
<h3>TypeScript</h3>
<pre class="line-numbers codeBox"><code class="language-typescript">class Planet {
    let mass: string;
    let moons: number;

    constructor (mass: string, moons: number) {
        this.mass  = mass;
        this.moons = moons || 0;
    }

    function reportMoons () {
        console.log(`I have ${this.moons} moons.`)
    }
}

// Yeah, Jupiter really does have (at least) 67 moons.
const jupiter = new Planet('Pretty Big', 67);
jupiter.reportMoons();</code></pre>
<h3>JavaScript:</h3>
<pre class="line-numbers codeBox"><code class="language-typescript">var Planet = (function () {
    function Planet() {

    }
    return Planet;
}());

var mass;
var moons;
constructor(mass, string, moons, number);
{
    this.mass = mass;
    this.moons = moons || 0;
}
function reportMoons() {
    console.log("I have " + this.moons + " moons.");
}
// Yeah, Jupiter really does have (at least) 67 moons.
var jupiter = new Planet('Pretty Big', 67);
jupiter.reportMoons();</code></pre>
<p>In this next example we can see how TypeScript changes when we write code implementing class inheritance, as you can
    see the JavaScript version is rather longer and more complex, but when examined a little more intentively we can see
    that TypeScript utilises the JavaScripts prototypes to actually define certain features of the object from a certain
    class</p>
<h3>TypeScript:
</h3>
<pre class="line-numbers codeBox"><code class="language-typescript">class Animal {
    constructor(public name: string) { }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
</code></pre>
<h3>JavaScript:</h3>
<pre class="line-numbers codeBox"><code class="language-typescript">var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Animal = (function () {
    function Animal(name) {
        this.name = name;
    }
    Animal.prototype.move = function (distanceInMeters) {
        if (distanceInMeters === void 0) { distanceInMeters = 0; }
        console.log(this.name + " moved " + distanceInMeters + "m.");
    };
    return Animal;
}());
var Snake = (function (_super) {
    __extends(Snake, _super);
    function Snake(name) {
        return _super.call(this, name) || this;
    }
    Snake.prototype.move = function (distanceInMeters) {
        if (distanceInMeters === void 0) { distanceInMeters = 5; }
        console.log("Slithering...");
        _super.prototype.move.call(this, distanceInMeters);
    };
    return Snake;
}(Animal));
var Horse = (function (_super) {
    __extends(Horse, _super);
    function Horse(name) {
        return _super.call(this, name) || this;
    }
    Horse.prototype.move = function (distanceInMeters) {
        if (distanceInMeters === void 0) { distanceInMeters = 45; }
        console.log("Galloping...");
        _super.prototype.move.call(this, distanceInMeters);
    };
    return Horse;
}(Animal));
var sam = new Snake("Sammy the Python");
var tom = new Horse("Tommy the Palomino");
sam.move();
tom.move(34);</code></pre>
</div>
</div>